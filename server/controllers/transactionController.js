const db = require('../config/db');

exports.createOrder = async (req, res) => {
  const connection = await db.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const { user_id, items, total_amount } = req.body;
    
    if (!items || !Array.isArray(items) || items.length === 0) {
      return res.status(400).json({ message: 'Order must contain items' });
    }
    
    const [orderResult] = await connection.query(
      'INSERT INTO orders (user_id, total_amount, status) VALUES (?, ?, ?)',
      [user_id, total_amount, 'pending']
    );
    
    const orderId = orderResult.insertId;
    
    for (const item of items) {
      const { product_id, quantity, price } = item;
      
      await connection.query(
        'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (?, ?, ?, ?)',
        [orderId, product_id, quantity, price]
      );
      
      await connection.query(
        'UPDATE products SET stock = stock - ? WHERE id = ?',
        [quantity, product_id]
      );
    }
    
    await connection.commit();
    
    const [orderDetails] = await db.query(
      `SELECT o.*, oi.product_id, oi.quantity, oi.price, p.name as product_name
       FROM orders o
       JOIN order_items oi ON o.id = oi.order_id
       JOIN products p ON oi.product_id = p.id
       WHERE o.id = ?`,
      [orderId]
    );
    
    res.status(201).json({ 
      message: 'Order created successfully', 
      order_id: orderId,
      details: orderDetails
    });
    
  } catch (error) {
    await connection.rollback();
    res.status(500).json({ message: error.message });
  } finally {
    connection.release();
  }
};

exports.getOrderById = async (req, res) => {
  try {
    const [orderDetails] = await db.query(
      `SELECT o.*, oi.product_id, oi.quantity, oi.price, p.name as product_name
       FROM orders o
       JOIN order_items oi ON o.id = oi.order_id
       JOIN products p ON oi.product_id = p.id
       WHERE o.id = ?`,
      [req.params.id]
    );
    
    if (orderDetails.length === 0) {
      return res.status(404).json({ message: 'Order not found' });
    }
    
    res.status(200).json(orderDetails);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.getUserOrders = async (req, res) => {
  try {
    const [orders] = await db.query(
      'SELECT * FROM orders WHERE user_id = ?',
      [req.params.userId]
    );
    
    res.status(200).json(orders);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.updateOrderStatus = async (req, res) => {
  try {
    const { status } = req.body;
    
    const [result] = await db.query(
      'UPDATE orders SET status = ? WHERE id = ?',
      [status, req.params.id]
    );
    
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: 'Order not found' });
    }
    
    res.status(200).json({ message: 'Order status updated successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.processPayment = async (req, res) => {
  try {
    const { order_id, payment_method, payment_details } = req.body;
    const [orders] = await db.query('SELECT * FROM orders WHERE id = ?', [order_id]);
    
    //Dragonpay payment gateway 

    if (orders.length === 0) {
      return res.status(404).json({ message: 'Order not found' });
    }
    
    const paymentSuccessful = true; //status to be changed in terms of payment gateway (dragonpay)
    
    if (paymentSuccessful) {
      await db.query('UPDATE orders SET status = ? WHERE id = ?', ['paid', order_id]);
      
      res.status(200).json({
        message: 'Payment processed successfully',
        transaction_id: 'TR' + Date.now(), //For now, transaction id is generated by the system
        order_id: order_id,
        status: 'paid'
      });
    } else {
      res.status(400).json({ message: 'Payment processing failed' });
    }
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
}; 